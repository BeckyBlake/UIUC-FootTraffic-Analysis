## Output Correctness of Each Algorithm
# File reader
The file reader starts off by initializing the helper file which in the case is the course catalog CSV. Then, it goes through each line in the catalog. It checks to see if the class on that specific line is what we are seeking for one of our classes. Any time there is a desired class we push it into a vector and increase the index we are at. In the file reader, there is a separate function "addClass" which adds it to the desiredClasses vector. Or, if the class is not the one we are looking for, it is stored in the otherClasses vector. Finally, we have to test for the edge case at the end to see if it is a desired class (since our algorithm was having issues originally). The output was a successful collection of the desired classes and the other classes that we did not want. To ensure the correctness of our output, we used multiple tests. We first tested to make sure our file reader instantiation worked. Then, we tested if a location was already pushed to our file reader, then don't push the location. Instead, simply add it as another class at that location. We then made sure that if we were pushing the location, it had at least one class that we wanted. Then, we checked to make sure that the classes contained in the locations were only classes that we wanted. After all those test cases ran and passed, we determined that our file reader was correct.

# Graph Implementation / BFS
For our graph implementation, we used the locations from the file reader as our vertices. Then, the edges between the vertices were any possible foot traffic between the locations. This wasn't a precise 1 for 1 that happens in the actual semester but more of an approximation. Since this was undirected, we were just able to add the weights by the amount of students / # of total locations. Then, we distributed it evenly. In order to accomplish these connections, we had to use BFS to iterate through each vertex and connect them properly. This one was MUCH harder to test since a lot of the expected results had to be calculated manually which included connecting the vertices and weight of the edges. However, eventually the program ran the same numbers as we had expected.

# Forced Directed Graph Drawing




## Leading Question
Our leading question was trying to determine the foot traffic between classes for students of certain majors or certain classes. It started off with just doing this for CS majors but with how we formatted out file reader, you could plug in any set of classes and produce a result.

In order to solve this, we had to incorporate a file reader, BFS, graphs and Dijkstra's algorithm. The file reader was used to read the CSV file. The CSV in our case was the course catalog UIUC uses for classes and registration. The reader took in the classes and all the possible locations they take place at. So, for instance, we want to look at CS225. It would store the locations that CS225 take place in. If we wanted to include labs, we could say it takes place in Foellinger and CIF. Those locations would be pushed to a location vector and the classes would be stored in the location. Then, incorporating a graph where the locations are the vertices and the edges are the foot traffic between the class, we used BFS. The BFS was to help us traverse the graph and connect any vertices that a student would need to travel to, to get to a class. With BFS completed, we have a graph that tells us the general foot traffic between classes given a certain schedule. Then, using Dijkstra's we could see the optimal distance to run into the least amount of students possible (after all, ECE and CS majors start getting quite smelly near final season ;) ). Finally, we used a force directed graph drawing to more clearly visualize what locations contain the highest amount of foot traffic.

We were able to discover which classes have generally the most foot traffic. Our code, while produces the correct output for what we told it to do, is not precise. While we have calculated foot traffic, it is more of a guesstimate since we do not have the exact schedules of every student nor the time and full classroom size. It also gave our group some insight on what a class scheduler online (such as UIUC self service) would look like. While we did calculate foot traffic, it wouldn't be too far off to change the code to reflect a schedule creater that determines if you CAN take a class at a given time and location. 
